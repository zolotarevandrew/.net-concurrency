Поколения (Generations 0, 1, 2)
LOH (Large Object Heap) и SOH (Small Object Heap)
Работа с IDisposable и Finalizers


- Объясни концепцию поколений в .NET Garbage Collector

Поколение 0 (Gen 0):
- Содержит объекты, которые только что были выделены.
- Удаляется чаще всего, поскольку большинство объектов "живут" недолго.
- Пример: локальные переменные в методах.

Поколение 1 (Gen 1):
- Хранит объекты, которые пережили одну сборку мусора в Gen 0.
- Считается промежуточным этапом между Gen 0 и Gen 2.
- Пример: объекты, которые временно сохраняются между вызовами методов.

Поколение 2 (Gen 2):
- Содержит объекты, которые пережили несколько сборок мусора.
- Частота очистки ниже, так как предполагается, что эти объекты "живут" долго.

Пример: статические данные, кэш или объекты в глобальной области видимости.

- Как .NET Garbage Collector управляет памятью для больших и малых объектов? 

SOH (Small Object Heap): для объектов размером до 85 КБ.

Малые объекты выделяются быстро благодаря механизму bump allocation (указатель просто сдвигается).
Уборка SOH выполняется часто, особенно в Gen 0.

LOH (Large Object Heap): для объектов размером свыше 85 КБ.

Большие объекты сложнее управляются из-за фрагментации.
Уборка мусора LOH запускается только при полной сборке Gen 2.
Используется для массивов, строк и других крупных структур

- В чем разница между методами Dispose и Finalize в .NET?

Dispose - Используется для освобождения управляемых и неуправляемых ресурсовю.
Finalize - Метод, вызываемый GC перед удалением объекта из памяти. Используется для освобождения только неуправляемых ресурсов.
Не гарантируется, когда будет вызван. Влияет на производительность, так как объект должен пройти через финализацию.


- Как правильно реализовать паттерн IDisposable в классе?

public class MyResource : IDisposable
{
    private bool _disposed = false;

    // Финализатор
    ~MyResource()
    {
        Dispose(false);
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this); // Отключение финализации
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed) return;

        if (disposing)
        {
            // Освобождение управляемых ресурсов
        }

        // Освобождение неуправляемых ресурсов
        _disposed = true;
    }
}

- Что произойдет, если забыть вызвать метод Dispose для объекта, реализующего IDisposable?

Управляемые ресурсы: могут быть освобождены GC, но позже, чем необходимо.
Неуправляемые ресурсы: не будут освобождены до финализации объекта, что может вызвать утечки памяти.


- Существует две кучи объектов: для объектов меньше 85K байт и, соответственно, больше либо равно 85К байт. 
Это сделано для того чтобы можно было воспользоваться алгоритмом сжатия кучи - Compact. 
Без деления на две кучи сборщик мусора работал бы очень долго;

- Также для малых объектов куча делится на три поколения. 
Это также сделано для того чтобы отработать освобождение памяти максимально быстро. 
Ведь вероятность того, что старый объект лишился последней ссылки намного ниже чем если бы ссылки на себя лишился только что созданный: такова структура бытия;

- 0 поколение создано фиксированных размеров чтобы гарантировать, что сборка мусора по времени не превысит некоторый лимит. 
Иначе это будет заметно для пользователя. 
На неограниченном объёме эта операция работала бы случайно-большое время;

- 2 поколение -- склад старых объектов. Он огромен и потому туда имеет смысл заглядывать максимально редко.
- 1 поколение -- промежуточный перевал между 0 и 2 поколениями чтобы объект - неудачник, не потерявший последнюю ссылку на себя при срабатывании GC не ушёл на склад старых объектов: в поколение 2. 
Это поколение также имеет фиксированный размер, но более крупное, чем поколение 0;

- Память линейна и поколения -- это по сути непрерывные отрезки этой памяти в том смысле что объекты разных поколений не перемешаны. 
Напротив, сначала идут объекты 2 поколения, затем - 1 поколения и в самом конце - 0 поколения.

- Помимо Compact существует второй алгоритм управления занятыми и свободными участками: Sweep. 
По сути это - список свободных участков кучи. 
Он работает в обоих кучах: и в LOH и в SOH. 
Когда в куче заканчивается место, вычисляются свободные участки. 
Если участки пригодны для размещения объектов, выделение продолжится на них. Иначе -- срабатывает Compact.

- Для SOH первым приоритетом отрабатывает Sweep, т.к. он легче, вторым - Compact. 
Для LOH - всегда Compact, т.к. сжимать кучу больших массивов не оптимально.