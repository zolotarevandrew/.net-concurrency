Ссылочные типы:
- У ссылочных типов в отличии от значимых детерминированное начало жизни. 
Другими словами они порождаются тогда и только тогда, когда кто-либо запросил их создание оператором new;

- Однако, они имеют недетерминированное освобождение: мы не знаем, когда произойдет освобождение памяти из под них.
Мы не можем вызвать GC для конкретного экземпляра даже для случая с Large Objects Heap, где эта операция могла бы быть вполне уместна;

- экземпляры классов уничтожаются в случайное время в неопределенно отдаленном будущем;
- их уничтожение обуславливается утерей ссылок на них;
- поэтому с одной стороны это значит, что операция освобождения последней ссылки на объект превращается в детерминированную операцию "удаления" объекта из зоны видимости приложения. 
Объект ещё существует, но недосягаем для всего приложения;
- однако, с другой стороны мы далеко не всегда в курсе, какое именно обнуление ссылки будет последним, что лишает нас свойства детерминированности в обнулении последней ссылки.

В терминологии оператора new языка C# - это запрос адреса оперативной памяти, который размечен под объект определенного типа. 
Т.е. выделение в некотором внешнем массиве (не более того) памяти под поля объекта + его системные поля (SyncBlockIndex, VMT) 
и отдача адреса этого участка коду вашей программы. 
Другими словами... это чисто программная вещь - выделить вам память под что-то. 
Результат точно таких же алгоритмов, которые мы с вами пишем ежедневно.


- Значимый тип: значением является вся структура целиком. Для ссылочного типа значением является ссылка на объект;
По структуре в памяти: значимые типы содержат только те данные, которые вы указали. Ссылочные также содержат два системных поля. Первое необходимо для хранения SyncBlockIndex, второе -- для хранения информации о типе: в том числе и о Virtual Methods Table (VMT)
- Однако, ссылочные типы можно наследовать, переопределяя методы. Значимые типы лишены такой возможности;

Но, чтобы выделить ссылочный тип, надо аллоцировать место в куче. Значимый тип может работать на стеке, не уходя в кучу, а может стать частью ссылочного типа. Это свойство может значительно повысить производительность для некоторых алгоритмов;

 DateTime dt = DateTime.Now;   // Здесь сначала при вызове метода будет выделено место под переменную DateTime,
                               // но заполнено оно будет нулями. Далее копируется все значение свойства Now в переменную dt
 DateTime dt2 = dt;            // Здесь значение копируется ещё раз

 object obj = new object();    // Создаём объект, выделяя память в SOH, и размещаем указатель на объект в переменной obj
 object obj2 = obj;            // Тут мы копируем ссылку на этот объект. Т.е. объект - один, а ссылок - две