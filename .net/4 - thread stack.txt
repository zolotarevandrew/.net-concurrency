1) Первое, что делает код, скомпилированный JIT'ом: он сохраняет параметры метода в стек (начиная с третьего). 
При этом первые два передаются через регистры. 
Тут важно помнить, что первым параметром экземплярных методов передаётся указатель на тот объект, с которым работает метод. 
Т.е. указатель this. Так что в этих (почти всех) случаях для регистров остаётся всего один параметр, а для всех остальных -- стек;

2) Далее компилятор ставит инструкцию вызова метода call, которая помещает в стек адрес возврата из метода: адрес следующей за call инструкцией. 
Таким образом любой метод знает, куда ему необходимо вернуться, чтобы вызывающий код смог продолжить работу;

3) После того как все параметры переданы, а метод вызван, нам надо как-то понять, как стек восстановить в случае выхода из метода, 
если мы не хотим заботиться о подсчёте занимаемых нами в стеке байтов. 
Для этого мы сохраняем значение регистра EBP, который всегда хранит указатель на начало текущего кадра стека 
(т.е. участка, где хранится информация для конкретного вызванного метода). 
Сохраняя при каждом вызове значение этого регистра, мы тем самым фактически создаём односвязный список стековых кадров. 
Но прошу заметить, что по факту они идут чётко друг за другом, без каких-либо пробелов. 
Однако для упрощения освобождения памяти из-под кадра и для отладки приложения 
(отладчик использует эти указатели, чтобы отобразить Stack Trace) строится односвязный список;

4) Последнее, что надо сделать при вызове метода, -- выделить участок памяти под локальные переменные. 
Поскольку компилятор заранее знает, сколько её понадобится, то делает он это сразу, сдвигая указатель на вершину стека (SP/ESP/RSP) на необходимое количество байт;

5) И наконец, на пятом этапе выполняется код метода, полезные операции;
Когда происходит выход из метода, то вершина стека восстанавливается из EBP -- места, где хранится начало текущего стекового кадра;
Далее, последним этапом осуществляется выход из метода через инструкцию ret. 
Она забирает со стека адрес возврата, заботливо оставленный ранее инструкцией call и делает jmp по этому адресу.


стек "растёт", начиная со старших адресов и заканчивая младшими, т.е. в обратную сторону.

main → FunctionA → FunctionB

1) main

Address   Data
-----------------
0x7FFC    Локальные переменные main
0x7FF8    Адрес возврата main (в точку выхода)
0x7FF4    Сохранённый EBP (нет предыдущего кадра)

2) Вызов FunctionA

Address   Data
-----------------
0x7FF8    Локальные переменные FunctionA
0x7FF4    Адрес возврата FunctionA (в main)
0x7FF0    Сохранённый EBP (main)
0x7FFC    Локальные переменные main
0x7FF8    Адрес возврата main
0x7FF4    Сохранённый EBP (нет предыдущего кадра)

3) Вызов FunctionB

Address   Data
-----------------
0x7FF4    Локальные переменные FunctionB
0x7FF0    Адрес возврата FunctionB (в FunctionA)
0x7FEC    Сохранённый EBP (FunctionA)
0x7FF8    Локальные переменные FunctionA
0x7FF4    Адрес возврата FunctionA
0x7FF0    Сохранённый EBP (main)
0x7FFC    Локальные переменные main
0x7FF8    Адрес возврата main
0x7FF4    Сохранённый EBP (нет предыдущего кадра)

Исключения

1) Вход в блок try:
Входя в блок try, программа создаёт структуру обработчика исключений (SEH Record) и добавляет её в стек.
Поля структуры:
- Указатель на предыдущий SEH Record.
- Тип обработчика (например, catch).
- Код исключения (если применимо).
- Адрес обработчика (куда передать управление при исключении).
Указатель на текущую вершину цепочки SEH в TEB обновляется, чтобы указывать на эту структуру.

2. Выход из блока try:
Когда выполнение блока try завершается, SEH Record удаляется из стека.
Указатель в TEB обновляется, чтобы указывать на предыдущий SEH Record.

3. Возникновение исключения:
При возникновении исключения операционная система обращается к текущей вершине SEH в TEB.
Система последовательно обходит цепочку SEH Records, пока не найдёт обработчик, способный обработать исключение.
Когда подходящий обработчик найден, выполняется код блока catch.

4. Восстановление цепочки:
После обработки исключения TEB восстанавливает указатель на предыдущий SEH Record, что позволяет продолжить выполнение программы.



Поток определяют следующие структуры и области данных:
- Набор регистров процессора. 
Все регистры определяют состояние потока исполнения инструкций: от адреса текущей инструкции исполнения до адресов стека потока и данных, которыми он оперирует;
- Thread Environment Block или TIB/TEB, который хранит системную информацию по потоку, включая адреса обработчиков исключений;
- Стек потока, адрес которого определяется регистрами SS:ESP;
- Платформенный контекст потока, который содержит локальные для потока данные (ссылка идёт из TIB).


Когда приложение резервирует память под локальные переменные, то происходят две вещи: 
- наращивается значение регистра ESP;
- зануляется память под сами переменные;

Поэтому, когда вы напишете рекурсивный метод, который уходит в бесконечную рекурсию, вы получите StackOverflowException: 
заняв всю выделенную под стек память (весь доступный регион), вы напоритесь на специальную страницу, Guard Page, 
доступ к которой вызовет нотификацию операционной системы, которая инициирует StackOverflow уровня ОС, которое уйдёт в .NET, 
будет перехвачено и выбросется исключение StackOverflowException для .NET приложения.

